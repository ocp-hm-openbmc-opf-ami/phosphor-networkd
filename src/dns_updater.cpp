#include "config.h"

#include "dns_updater.hpp"

#include "config_parser.hpp"
#include "ethernet_interface.hpp"
#include "network_manager.hpp"
#include "types.hpp"
#include "util.hpp"

#include <fmt/compile.h>
#include <fmt/format.h>
#include <sys/stat.h>

#include <phosphor-logging/elog-errors.hpp>
#include <phosphor-logging/lg2.hpp>
#include <xyz/openbmc_project/Common/error.hpp>

#include <cstdlib>
#include <fstream>

namespace phosphor
{
namespace network
{
namespace dns
{
namespace updater
{

void updateDNSEntries(const fs::path& inFile, const fs::path& outFile)
{
    using namespace phosphor::logging;
    using namespace sdbusplus::xyz::openbmc_project::Common::Error;

    std::fstream outStream(outFile, std::fstream::out);
    if (!outStream.is_open())
    {
        lg2::error("Unable to open output file {FILE}", "FILE", outFile);
        elog<InternalFailure>();
    }

    std::fstream inStream(inFile, std::fstream::in);
    if (!inStream.is_open())
    {
        lg2::error("Unable to open the input file {FILE}", "FILE", inFile);
        elog<InternalFailure>();
    }

    outStream << "### Generated by phosphor-networkd ###\n";

    for (std::string line; std::getline(inStream, line);)
    {
        auto index = line.find("DNS=");
        if (index != std::string::npos)
        {
            auto dns = line.substr(index + 4);
            outStream << "nameserver " << dns << "\n";
        }
    }
    return;
}

} // namespace updater

using namespace phosphor::network;
using namespace phosphor::logging;
using namespace sdbusplus::xyz::openbmc_project::Common::Error;
using Unsupported = xyz::openbmc_project::Common::UnsupportedRequest;

constexpr auto NSUPDATE_TMP_FILE = "/etc/dns.d/nsupdate_tmp";
constexpr auto RESOLVED_SERVICE = "org.freedesktop.resolve1";
constexpr auto RESOLVED_INTERFACE = "org.freedesktop.resolve1.Link";
constexpr auto PROPERTY_INTERFACE = "org.freedesktop.DBus.Properties";
constexpr auto RESOLVED_SERVICE_PATH = "/org/freedesktop/resolve1/link/";

constexpr auto DHCP_PROP_INTERFACE =
    "xyz.openbmc_project.Network.DHCPConfiguration";
constexpr auto DHCP_SERVICE_PATH = "/xyz/openbmc_project/network/dhcp";

constexpr auto SYSTEMCONF_PROP_INTERFACE =
    "xyz.openbmc_project.Network.SystemConfiguration";
constexpr auto SYSTEMCONF_SERVICE_PATH = "/xyz/openbmc_project/network/config";

constexpr auto BMC_STATE_PROP_INTERFACE = "xyz.openbmc_project.State.BMC";
constexpr auto BMC_STATE_SERVICE_PATH = "/xyz/openbmc_project/state/bmc0";

constexpr char HOSTNAMED_SVC[] = "org.freedesktop.hostname1";
constexpr char HOSTNAMED_OBJ[] = "/org/freedesktop/hostname1";
constexpr char HOSTNAMED_INTF[] = "org.freedesktop.hostname1";

constexpr auto DEFAULT_HOSTNAME_PATH = "/etc/hostname_default";
constexpr auto CURRENT_MAC_PATH = "/sys/class/net/eth0/address";
constexpr auto GET = "Get";
constexpr auto DNS_CONF_DIR = "/etc/dns.d";
constexpr auto DNS_CONF = "/etc/dns.d/dns.conf";
constexpr auto DNS_CONF_BAK = "/etc/dns.d/dns.conf.bak";
constexpr auto TTL = "86400";
constexpr auto DELAYED_SEC = 3;

std::mutex g_mutex;

std::map<std::string, std::unique_ptr<sdbusplus::bus::match_t>> signals;

Configuration::Configuration(sdbusplus::bus_t& bus, stdplus::const_zstring path,
                             Manager& parent) :
    Iface(bus, path.c_str(), Iface::action::defer_emit),
    bus(bus), manager(parent)
{
    config::Parser conf;
#if 0
    {
        ddnsIface::dnsEnabled(manager.get().getDHCPConf().dnsEnabled());
    }
#endif
    fs::path dnsDir(DNS_CONF_DIR);
    if (!fs::exists(dnsDir))
    {
        if (!fs::create_directories(dnsDir))
        {
            lg2::error("Unable to create the dns conf dir");
            elog<InternalFailure>();
        }
    }

    if (fs::exists(DNS_CONF_DIR) && fs::exists(DNS_CONF))
    {
        updateDNSInfo(false);
        updateDNSInfo(true);
    }
    else
    {
        {
            ddnsIface::hostConf(std::make_tuple(
                true, manager.get().getSystemConf().hostName()));
        }
        // {
        //     if (getDHCPProp(conf, "UseDomains") && dnsEnabled()) {
        //          ddnsIface::domainConf(std::make_tuple(true,1, ""));
        //     }
        //     else{
        //         ddnsIface::domainConf(std::make_tuple(false,0, ""));
        //     }
        // }
        {
            ddnsIface::useMDNS(true, true);
        }
    }

    signals = initSignals();
    registerSignal(bus);
    emit_object_added();

    ddnsIface::setInProgress(false);
    dnsLock = std::unique_lock(dnsMutex);
    dnsWorker = std::thread(&Configuration::dnsWorkerFunc, this);
}

Configuration::~Configuration()
{
    dnsWorker.std::thread::~thread();
}

// Add new signal here
std::map<std::string, std::unique_ptr<sdbusplus::bus::match_t>>
    Configuration::initSignals()
{
    std::map<std::string, std::unique_ptr<sdbusplus::bus::match_t>> mp;
#if 0
    mp["DHCPSignal"] = nullptr;
#endif
    mp["SystemconfigSignal"] = nullptr;
    mp["BMCStateSignal"] = nullptr;
    return mp;
}

void Configuration::registerSignal(sdbusplus::bus_t& bus)
{
    for (auto& signal : signals)
    {
        if (signal.second == nullptr && signal.first == "DHCPSignal")
        {
            signal.second = std::make_unique<sdbusplus::bus::match_t>(
                bus,
                sdbusplus::bus::match::rules::propertiesChanged(
                    DHCP_SERVICE_PATH, DHCP_PROP_INTERFACE),
                [&](sdbusplus::message::message& msg) {
                std::map<
                    std::string,
                    std::variant<std::string, std::vector<std::string>, bool>>
                    props;
                std::string iface;
                bool value;
                msg.read(iface, props);
                for (const auto& t : props)
                {
#if 0
                        if (t.first == "DomainEnabled")
                        {
                            value = std::get<bool>(t.second);
                            if (value == true && dnsEnabled())
                                domainConf(std::make_tuple(true,1, ""));
                            else {
                                domainConf(std::make_tuple(false,0, std::get<2>(ddnsIface::domainConf())));
                            }
                        }
                        else if (t.first == "DNSEnabled")
                        {
                            value = std::get<bool>(t.second);
                            dnsEnabled(value);
                        }
                        else if (t.first == "SendNsupdateEnabled")
                        {
                            value = std::get<bool>(t.second);
                            if (!value) {
                                NsupdateEnabledChanged=true;
                                toDeregister();
                                NsupdateEnabledChanged=false;
                            }
                        }
#endif
                }
            });
        } // if
        else if (signal.second == nullptr &&
                 signal.first == "SystemconfigSignal")
        {
            signal.second = std::make_unique<sdbusplus::bus::match_t>(
                bus,
                sdbusplus::bus::match::rules::propertiesChanged(
                    SYSTEMCONF_SERVICE_PATH, SYSTEMCONF_PROP_INTERFACE),
                [&](sdbusplus::message::message& msg) {
                std::map<
                    std::string,
                    std::variant<std::string, std::vector<std::string>, bool>>
                    props;
                std::string iface;
                std::string value;
                msg.read(iface, props);
                for (const auto& t : props)
                {
                    if (t.first == "HostName")
                    {
                        value = std::get<std::string>(t.second);
                        hostConf(std::make_tuple(false, value));
                        if (ddnsIface::useMDNS())
                        {
#if AVAHI_SUPPORT
                            execute("/bin/systemctl", "systemctl", "restart",
                                    "avahi-daemon");
                            std::this_thread::sleep_for(
                                std::chrono::seconds(1));
                            execute("/bin/systemctl", "systemctl",
                                    "reset-failed", "avahi-daemon");
#else
			    log<level::ERR>(
			        "AVAHI Support is not enabled..\n");
#endif                    
		    	}
                    }
                }
            });
        } // else if
        else if (signal.second == nullptr && signal.first == "BMCStateSignal")
        {
            signal.second = std::make_unique<sdbusplus::bus::match_t>(
                bus,
                sdbusplus::bus::match::rules::propertiesChanged(
                    BMC_STATE_SERVICE_PATH, BMC_STATE_PROP_INTERFACE),
                [&](sdbusplus::message::message& msg) {
                std::map<
                    std::string,
                    std::variant<std::string, std::vector<std::string>, bool>>
                    props;
                std::string iface;
                msg.read(iface, props);
                for (const auto& t : props)
                {
                    if (t.first == "CurrentBMCState")
                    {
                        sdbusplus::common::xyz::openbmc_project::state::BMC::
                            BMCState state =
                                sdbusplus::common::xyz::openbmc_project::state::
                                    BMC::convertBMCStateFromString(
                                        std::get<std::string>(t.second));
                        if (state == sdbusplus::common::xyz::openbmc_project::
                                         state::BMC::BMCState::Ready)
                        {
                            // Reload Configuration for HOSTNAME chagend during BOOT
                            // If not, DDNS may not work
                            manager.get().addReloadPreHook(
                            [&]() {
                                // Wait for the information of interface ready
                                // Since reloadConfig is async
                                std::this_thread::sleep_for(std::chrono::seconds(5));
                                toRegister();
                            });
                            manager.get().reloadConfigs();
                            if (!std::filesystem::exists(DEFAULT_HOSTNAME_PATH))
                            {
                                std::ofstream ofs;
                                ofs.open(DEFAULT_HOSTNAME_PATH);
                                if (ofs.is_open())
                                {
                                    ofs << manager.get()
                                               .getSystemConf()
                                               .hostName();
                                    ofs.close();
                                    hostConf(std::make_tuple(
                                        true, manager.get()
                                                  .getSystemConf()
                                                  .hostName()));
                                }
                            }
                        }
                    }
                }
            });
        }
    }
}

int16_t Configuration::doNsupdate()
{
    if (ddnsIface::setInProgress() == true)
    {
        lg2::info("Nsupdate is now performed...\n");
        return -1;
    }

    for (int i = 0; i < DELAYED_SEC; i++)
    {
        auto info = fmt::format("DNS restart waiting...\n");
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }

    if (fs::exists(DNS_CONF_BAK))
    {
        toDeregister();
    }

    toRegister();
    return 0;
}

void Configuration::dnsWorkerFunc()
{
    while (true)
    {
        dnsCondVar.wait(dnsLock);
        ddnsIface::setInProgress(true);
        while (!dnsWorkq.empty())
        {
            dnsWorkq.front()();
            dnsWorkq.pop();
        }

        ddnsIface::setInProgress(false);
        fs::copy_file(DNS_CONF, DNS_CONF_BAK,
                      fs::copy_options::overwrite_existing);
    }
}

int16_t Configuration::toDeregister()
{
    std::string info;
    std::ofstream ofs;
    if (!fs::exists(DNS_CONF_BAK))
    {
        lg2::info("No need to do reregister\n");
        return 0;
    }

    if (!sendNsupdateEnabled() && !NsupdateEnabledChanged)
    {
        lg2::error("sendNsupdateEnabled is not enabled...\n");
        return -1;
    }

    if(updateDNSInfo(true) == -1) return -1;
    auto [setting, hostname] = preHost;
    for (auto it = preIfaceConf.begin(); it != preIfaceConf.end(); it++)
    {
        std::string iName;
        bool doNsupdate, tsig;
        Method method;
        std::tie(iName, doNsupdate, tsig, method) = (*it);
        auto iface = manager.get().interfaces.find(iName);
        if (iface == manager.get().interfaces.end())
        {
            lg2::info("Interface not found: {INAME}\n", "INAME", iName);
        }

        for (int i = 1; true; i++)
        {
            std::filesystem::path delFile(
                fmt::format("{}-del-{}-{}", NSUPDATE_TMP_FILE, iName, i)
                    .c_str());
            if (!std::filesystem::exists(delFile))
            {
                break;
            }
            std::error_code ec;
            std::filesystem::remove(delFile, ec);
        }

        if (method == Method::Deregister || doNsupdate == false)
        {
            continue;
        }

        std::vector<std::string> dnsServers;
        std::vector<std::string> IPs;
        std::vector<std::string> domainNameList;
        for (auto& vv : preDomain)
        {
            auto [domainIface, name] = vv;
            if (domainIface == iName)
            {
                domainNameList = name;
                break;
            }
        }

        for (auto& vv : preDns)
        {
            auto [dnsName, servers] = vv;
            if (dnsName == iName)
            {
                dnsServers = servers;
                break;
            }
        }

        for (auto& vv : preIPAddr)
        {
            auto [ipName, tmpIPs] = vv;
            if (ipName == iName)
            {
                IPs = tmpIPs;
                break;
            }
        }

        auto i = 1;
        for (auto& domainName : domainNameList)
        {
            for (auto& dns : dnsServers)
            {
                for (auto& ip : IPs)
                {
                    ofs.open(
                        fmt::format("{}-del-{}-{}", NSUPDATE_TMP_FILE, iName, i)
                            .c_str());
                    if (!ofs.is_open())
                    {
                        lg2::error(
                            "Cannot create {NSUPDATE_TMP_FILE}-del-{NAME}-{INDEX}\n",
                            "NSUPDATE_TMP_FILE", NSUPDATE_TMP_FILE, "NAME",
                            iName, "INDEX", i);
                        return -1;
                    }
                    auto cmd = fmt::format("server {}\n", dns);
                    ofs << cmd;
                    lg2::info(cmd.c_str());
                    bool ipv6 = ip.find(":") == std::string::npos ? false
                                                                  : true;
                    std::string revIP = ipv6 == true ? getRevIPv6(ip)
                                                     : getRevIPv4(ip);
                    cmd = fmt::format("update delete {}.{} {}\n", hostname,
                                      domainName, ipv6 ? "AAAA" : "A");
                    lg2::info(cmd.c_str());
                    // There must be a blank line between PTR and A/AAAA record
                    ofs << cmd << std::endl;
                    cmd = fmt::format("update delete {} {} PTR {}.{}\n", revIP,
                                      TTL, hostname, domainName);
                    lg2::info(cmd.c_str());
                    // There must be a blank line between PTR and A/AAAA record
                    ofs << cmd << std::endl << "send" << std::endl;
                    ofs.close();
                    i++;
                }
            }
        }

        dnsWorkq.push([iName]() {
            execute("/usr/bin/nsupdate.sh", "nsupdate.sh", "deregister",
                    iName.c_str());
        });
    }

    dnsCondVar.notify_one();
    return 0;
}

int16_t Configuration::toRegister()
{
    std::ofstream ofs;
    int ret = 0;
    std::string info;

    if (!sendNsupdateEnabled())
    {
        lg2::error("sendNsupdateEnabled is not enabled...\n");
        return -1;
    }

    auto [setting, hostname] = ddnsIface::hostConf();
    std::vector<std::tuple<std::string, bool, bool, ddnsIface::Method>>
        interfaceConf(ddnsIface::interfacesConf());
    for (auto it = interfaceConf.begin(); it != interfaceConf.end(); it++)
    {
        std::string iName;
        bool doNsupdate, tsig;
        Method method;
        std::tie(iName, doNsupdate, tsig, method) = (*it);
        auto iface = manager.get().interfaces.find(iName);
        if (iface == manager.get().interfaces.end())
        {
            lg2::info("Interface not found: {INAME} \n", "INAME", iName);
            continue;
        } //

        for (int i = 1; true; i++)
        {
            std::filesystem::path delFile(
                fmt::format("{}-add-{}-{}", NSUPDATE_TMP_FILE, iName, i)
                    .c_str());
            if (!std::filesystem::exists(delFile))
            {
                break;
            }
            std::error_code ec;
            std::filesystem::remove(delFile, ec);
        }

        if (method != Method::Register || doNsupdate == false)
        {
            continue;
        }

        std::vector<std::string> domainNames = getDomainName(iName);
        if (domainNames.empty())
        {
            lg2::info("Domain Name isn't set.\n");
            continue;
        }

        auto i = 1;
        for (auto& domainName : domainNames)
        {
            std::vector<std::string> dnsServers = getDNSServer(iName);
            if (dnsServers.empty())
            {
                lg2::info("DNS Server isn't set.\n");
                continue;
            }

            for (auto& dns : dnsServers)
            {
                for (auto& addr : iface->second->addrs)
                {
                    std::string ip = stdplus::toStr(addr.first);
                    bool ipv6 = ip.find(":") == std::string::npos ? false
                                                                  : true;
                    auto index = ip.find_first_of("/");
                    ip.assign(ip.begin(), ip.begin() + index);
                    if (ipv6)
                    {
                        in6_addr tmp = stdplus::fromStr<stdplus::In6Addr>(ip);
                        if (IN6_IS_ADDR_LINKLOCAL((in6_addr*)&tmp))
                            continue;
                    }
                    ofs.open(
                        fmt::format("{}-add-{}-{}", NSUPDATE_TMP_FILE, iName, i)
                            .c_str());
                    if (!ofs.is_open())
                    {
                        lg2::error(
                            "Cannot create {NSUPDATE_TMP_FILE}-add-{NAME}-{INDEX}\n",
                            "NSUPDATE_TMP_FILE", NSUPDATE_TMP_FILE, "NAME",
                            iName, "INDEX", i);
                        return -1;
                    }
                    auto cmd = fmt::format("server {}\n", dns);
                    ofs << cmd;
                    lg2::info(cmd.c_str());
                    cmd = fmt::format("update add {}.{} {} {} {}\n", hostname,
                                      domainName, TTL, ipv6 ? "AAAA" : "A", ip);
                    // There must be a blank line between PTR and A/AAAA record
                    ofs << cmd << std::endl;
                    lg2::info(cmd.c_str());
                    std::string revIP = ipv6 == true ? getRevIPv6(ip)
                                                     : getRevIPv4(ip);
                    cmd = fmt::format("update add {} {} PTR {}.{}\n", revIP,
                                      TTL, hostname, domainName);
                    // There must be a blank line between PTR and A/AAAA record
                    ofs << cmd << std::endl << "send" << std::endl;
                    lg2::info(cmd.c_str());
                    ofs.close();
                    i++;
                }
            }
        }

        dnsWorkq.push([iName]() {
            execute("/usr/bin/nsupdate.sh", "nsupdate.sh", "register",
                    iName.c_str());
        });
    }

    writeConfigurationFile();
    dnsCondVar.notify_one();
    return 0;
}

int16_t Configuration::setHostConf(bool hostSetting, std::string hostName)
{
    bool different = false;
    std::string hostname;
    std::string hw_mac;
    const char invalidChar[] = "{}()<>&*`|=?;[]$#~!\"%/\\:+,'.";
    if (hostSetting)
    {
        std::fstream inStream(DEFAULT_HOSTNAME_PATH, std::fstream::in);
        if (!inStream.is_open())
        {
            lg2::error("Unable to open the input file.");
            return -1;
        }
        else
        {
	    std::getline(inStream, hostname);
            std::fstream inStream(CURRENT_MAC_PATH, std::fstream::in);
            if (!inStream.is_open())
            {
                lg2::error("Unable to open the input file.");
                inStream.close();
                return -1;
            }
            else
            {
                std::getline(inStream, hw_mac);
                hw_mac.erase(std::remove(hw_mac.begin(), hw_mac.end(), ':'), hw_mac.end());
                hostname =  "AMIOT-" + hw_mac;
                std::string cmd = "hostnamectl set-hostname " + hostname;
                int result = std::system(cmd.c_str());
                inStream.close();
            }
        }

        different = true;
    } // if
    else if (!hostSetting)
    {
        if (std::get<1>(ddnsIface::hostConf()) != hostName)
        {
            if (hostName.size() > 63)
            {
                lg2::error(
                    "Unable to hostname since hostname size isn't in range ( 0 - 64 )");
                return -1;
            } // if
            else if (strstr(hostname.c_str(), "--") != NULL ||
                     strpbrk(hostName.c_str(), invalidChar) != NULL)
            {
                lg2::error(
                    "Unable to hostname since hostname contains invalid charactor\n");
                return -1;
            }
            hostname = hostName;
            different = true;
        } // if
    }     // else if

    if (different)
    {
        toDeregister();
        manager.get().getSystemConf().hostName(hostname, true);
        hostConf(std::make_tuple(hostSetting, hostname));
        auto method = bus.new_method_call(HOSTNAMED_SVC, HOSTNAMED_OBJ,
                                          HOSTNAMED_INTF, "SetStaticHostname");
        method.append(hostname, /*interactive=*/false);
        bus.call(method);
        for (auto it = manager.get().interfaces.begin();
             it != manager.get().interfaces.end(); it++)
        {
            if (it->second->interfaceName().find(".") == std::string::npos &&
                it->second->interfaceName().find_first_of("eth") !=
                    std::string::npos)
                manager.get().reconfigLink(it->second->getIfIdx());
                std::this_thread::sleep_for(std::chrono::seconds(1));
        }
        toRegister();
    }

    if (ddnsIface::useMDNS())
    {
#if AVAHI_SUPPORT
        execute("/bin/systemctl", "systemctl", "restart", "avahi-daemon");
        std::this_thread::sleep_for(std::chrono::seconds(1));
        execute("/bin/systemctl", "systemctl", "reset-failed", "avahi-daemon");
#else
        log<level::ERR>(
            "AVAHI Support is not enabled..\n");
#endif
    }

    return 0;
}

int16_t Configuration::setInterfacesConf(
    std::vector<std::tuple<std::string, bool, bool, Method>> interfaceConf)
{
    for (auto it = interfaceConf.begin(); it != interfaceConf.end(); it++)
    {
        auto [interface, doNsupdate, tsig, method] = (*it);
            
	if(tsig == true)
        {
#if !TSIG_SUPPORT		 
	      log<level::ERR>(
                  "TSIG support is not enabled..\n");
              elog<UnsupportedRequest>(
                  Unsupported::REASON("TSIG support is not enabled..\n"));        
#endif
	 }
        if (manager.get().interfaces.find(interface) ==
            manager.get().interfaces.end())
        {
            lg2::error(
                "Unable to hostname since hostname contains invalid charactor\n");
            return -1;
        }
    }

    interfacesConf(interfaceConf);
    return 0;
}

#if 0
int16_t Configuration::setDomainConf(bool dhcp, uint8_t priority,std::string domainName) {
    auto [dominaDHCP, domainPriority, DomainDN] = ddnsIface::domainConf();
    if ( dhcp == dominaDHCP && priority == domainPriority && domainName ==  DomainDN) {
        return 0;
    }

    if (dnsEnabled() == false && dhcp == true) {
        lg2::info("Cannot enable Domain DHCP\n");
        return -1;
    }
    manager.get().getDHCPConf().domainEnabled(dhcp);
    if (domainName.size() > 0) {
        domainConf(std::make_tuple(dhcp, priority, domainName));
    }
    else
        domainConf(std::make_tuple(dhcp, priority, ""));

    std::vector<std::string> tmpVec;
    if (!dhcp) {
        tmpVec.push_back(domainName);
    }

    for (auto i = manager.get().interfaces.begin(); i != manager.get().interfaces.end(); i++) {
        if (i->second->linkUp()) {
            i->second->domainName({});
        }
    }

    return 0;
}
#endif

int16_t Configuration::setDNSServer(std::string interface,
                                    std::vector<std::string> servers)
{
    auto iface = manager.get().interfaces.find(interface);
    if (iface == manager.get().interfaces.end())
    {
        lg2::info("Interface not found: {INTERFACE}\n", "INTERFACE", interface);
        return -1;
    }

    for (auto& ipaddress : servers)
    {
        try
        {
            if (ipaddress.find(":") != std::string::npos &&
                iface->second->dhcp6Conf->dnsEnabled())
            {
                lg2::error("Not support in currnt state.\n");
                return -1;
            } // if
            else if (ipaddress.find(":") == std::string::npos &&
                     iface->second->dhcp4Conf->dnsEnabled())
            {
                lg2::error("Not support in currnt state.\n");
                return -1;
            }

            /* DNS Server IP "0.0.0.0" is invalid and hence should be blocked */
            if (ipaddress.compare("0.0.0.0") == 0)
            {
                lg2::error("Invalid IP `{IPADDRESS}`: invalid_argument\n",
                           "IPADDRESS", ipaddress);
                return -1;
            }
	    stdplus::fromStr<stdplus::InAnyAddr>(ipaddress);
        }
        catch (std::invalid_argument e)
        {
            lg2::error("Invalid IP `{IPADDRESS}`: invalid_argument\n",
                       "IPADDRESS", ipaddress);
            return -1;
        }
	catch (const std::exception& e)
        {
            lg2::error("Invalid IP `{IPADDRESS}`: {ERROR}\n",
                       "IPADDRESS", ipaddress, "ERROR", e.what());
            return -1;
        }
    }
    try{
	auto result = iface->second->staticNameServers(servers);
    	if (servers.size() == 0 && result.size() == 0)
   	{
            writeConfigurationFile();
            return 0;
    	}
    	else if (result.size() == 0)
    	{
           return -1;
        }
        writeConfigurationFile();

        return 0;
    }
    catch (const sdbusplus::exception::SdBusError& e)
    {
        lg2::error("D-Bus error while setting DNS servers: {ERROR}", "ERROR", e);
        auto dbusError = e.get_error();
        if ((dbusError != nullptr) &&
            ((strcmp(dbusError->name, "org.freedesktop.DBus.Error.Disconnected") == 0) ||
             (strcmp(dbusError->name, "org.freedesktop.DBus.Error.NoReply") == 0)))
        {
            lg2::error("Remote peer disconnected error detected in setDNSServer");
        }
        return -1;
    }
    catch (const std::exception& e)
    {
        lg2::error("Exception while setting DNS servers: {ERROR}", "ERROR", e);
        return -1;
    }
}

#if 0
bool Configuration::dnsEnabled(bool value) {
    if (value == dnsEnabled()) {
        return value;
    }

    auto name = ddnsIface::dnsEnabled(value);
    auto [_, priority, dn] =  domainConf();
    if (value) {
        std::vector<std::string> empty;
        for (auto iface = manager.get().interfaces.begin(); iface != manager.get().interfaces.end(); iface++) {
            iface->second->staticNameServers(empty);
        }
        setDomainConf(true, priority, dn);
    }
    else if (!value) {
        setDomainConf(false, 0, dn);
    }

    writeConfigurationFile();
    return name;
}
#endif

std::tuple<bool, std::string>
    Configuration::hostConf(std::tuple<bool, std::string> value)
{
    auto [hostSetting, hostName] = value;
    ddnsIface::hostConf(value);
    writeConfigurationFile();
    return value;
}

std::vector<std::tuple<std::string, bool, bool, ddnsIface::Method>>
    Configuration::interfacesConf(
        std::vector<std::tuple<std::string, bool, bool, Method>> value)
{
    ddnsIface::interfacesConf(value);
    writeConfigurationFile();
    return value;
}

#if 0
std::tuple<bool, uint8_t, std::string> Configuration::domainConf(std::tuple<bool, uint8_t, std::string> value) {
    auto [DHCP, priority, name] = value;
    ddnsIface::domainConf(value);
    writeConfigurationFile();
    return value;
}
#endif

std::vector<std::string> Configuration::getDomainName(std::string interface)
{
#if 1
    std::vector<std::string> DomainNames;
    auto iface = manager.get().interfaces.find(interface);
    if (iface == manager.get().interfaces.end())
    {
        return {};
    }

    uint8_t index = iface->second->getIfIdx();
    auto OBJ_PATH = fmt::format("{}{}", RESOLVED_SERVICE_PATH, index);
    using type = std::vector<std::tuple<std::string, bool>>;
    std::variant<type> names;
    auto method = bus.new_method_call(RESOLVED_SERVICE, OBJ_PATH.c_str(),
                                      PROPERTY_INTERFACE, GET);

    method.append(RESOLVED_INTERFACE, "Domains");

    try
    {
        auto reply = bus.call(method);
        reply.read(names);
    }
    catch (const sdbusplus::exception_t& e)
    {
        lg2::error("Failed to get DNS information from Systemd-Resolved. {E}",
                   "E", e.what());
        return {};
    }
    auto tupleVector = std::get_if<type>(&names);
    for (auto i = tupleVector->begin(); i != tupleVector->end(); ++i)
    {
        auto [domainName, fromRoute] = (*i);
        DomainNames.push_back(domainName);
    }

    return DomainNames;
}
#else
    auto [DHCP, priority, name] = ddnsIface::domainConf();
    std::vector<std::string> DomainNames;
    if (DHCP && dnsEnabled())
    {
        auto iface = manager.get().interfaces.find(interface);
        if (iface == manager.get().interfaces.end())
        {
            return "";
        }

        uint8_t index = iface->second->getIfIdx();
        auto OBJ_PATH = fmt::format("{}{}", RESOLVED_SERVICE_PATH, index);
        using type = std::vector<std::tuple<std::string, bool>>;
        std::variant<type> names;
        auto method = bus.new_method_call(RESOLVED_SERVICE, OBJ_PATH.c_str(),
                                          PROPERTY_INTERFACE, GET);

        method.append(RESOLVED_INTERFACE, "Domains");

        try
        {
            auto reply = bus.call(method);
            reply.read(names);
        }
        catch (const sdbusplus::exception_t& e)
        {
            lg2::error(
                "Failed to get DNS information from Systemd-Resolved. {E}", "E",
                e.what());
            return "";
        }
        auto tupleVector = std::get_if<type>(&names);
        for (auto i = tupleVector->begin(); i != tupleVector->end(); ++i)
        {
            auto [domainName, fromRoute] = (*i);
            DomainNames.push_back(domainName);
        }

        if (DomainNames.size() >= 1)
        {
            if (priority == 1)
            {
                return DomainNames.at(0);
            }
            else
            {
                return DomainNames.at(DomainNames.size() - 1);
            }
        }
        else
        {
            return "";
        }
    }
    else
    {
        return name;
    }
}
#endif

std::vector<std::string> Configuration::getDNSServer(std::string interface)
{
    std::vector<std::string> servers;
    auto iface = manager.get().interfaces.find(interface);
    if (iface == manager.get().interfaces.end())
    {
        lg2::error("Interface not found: {INTERFACE}\n", "INTERFACE",
                   interface);
        return {};
    }

    uint8_t index = iface->second->getIfIdx();
    auto OBJ_PATH = fmt::format("{}{}", RESOLVED_SERVICE_PATH, index);
    using type = std::vector<std::tuple<int32_t, std::vector<uint8_t>>>;
    std::variant<type> names;
    auto method = bus.new_method_call(RESOLVED_SERVICE, OBJ_PATH.c_str(),
                                      PROPERTY_INTERFACE, GET);

    method.append(RESOLVED_INTERFACE, "DNS");

    try
    {
        auto reply = bus.call(method);
        reply.read(names);
    }
    catch (const sdbusplus::exception_t& e)
    {
        lg2::error("Failed to get DNS information from Systemd-Resolved");
        return {};
    }
    auto tupleVector = std::get_if<type>(&names);
    for (auto i = tupleVector->begin(); i != tupleVector->end(); ++i)
    {
        auto [addrFamily, ipaddress] = (*i);
        servers.push_back(stdplus::toStr(
            addrFromBuf(addrFamily, stdplus::raw::asView<char>(ipaddress))));
    }

    return std::move(servers);
}

std::string Configuration::getRevIPv4(std::string ipv4)
{
    in_addr addr = stdplus::fromStr<stdplus::In4Addr>(ipv4);
    std::string revIP4 =
        fmt::format("{}.{}.{}.{}.in-addr.arpa", (addr.s_addr >> 24) & 0xFF,
                    (addr.s_addr >> 16) & 0xFF, (addr.s_addr >> 8) & 0xFF,
                    addr.s_addr & 0xFF);
    return revIP4;
}

std::string Configuration::getRevIPv6(std::string ipv6)
{
    in6_addr addr = stdplus::fromStr<stdplus::In6Addr>(ipv6);
    std::string revIP6 = "";
    for (int i = 15; i >= 0; i--)
    {
        revIP6 += fmt::format("{:x}.{:x}.", addr.s6_addr[i] & 0b1111,
                              (addr.s6_addr[i] >> 4) & 0b1111);
    }

    revIP6 += "ip6.arpa";
    return revIP6;
}

void Configuration::addInterfaceConf(std::string interface)
{
    bool found = false;
    std::vector<std::tuple<std::string, bool, bool, ddnsIface::Method>>
        tmpIface = ddnsIface::interfacesConf();
    for (auto& vv : tmpIface)
    {
        auto [name, doNsupdate, tsig, method] = vv;
        if (interface == name)
        {
            found = true;
            break;
        }
    }

    if (found == false)
    {
        tmpIface.push_back(
            std::tuple(interface, true, false, ddnsIface::Method::Register));
        ddnsIface::interfacesConf(std::move(tmpIface));
    }
}

bool Configuration::useMDNS(bool value)
{
#if AVAHI_SUPPORT
    if (value == ddnsIface::useMDNS())
    {
        return value;
    }
    ddnsIface::useMDNS(value);
    if (value)
    {
        execute("/bin/systemctl", "systemctl", "enable", "avahi-daemon");
        execute("/bin/systemctl", "systemctl", "start", "avahi-daemon");
        execute("/bin/systemctl", "systemctl", "reset-failed", "avahi-daemon");
    } // if
    else
    {
        execute("/bin/systemctl", "systemctl", "stop", "avahi-daemon");
        execute("/bin/systemctl", "systemctl", "reset-failed", "avahi-daemon");
        execute("/bin/systemctl", "systemctl", "disable", "avahi-daemon");
    } // else

    writeConfigurationFile();

    return value;
#else
    log<level::ERR>(
        "AVAHI Support is not enabled..\n");
    elog<UnsupportedRequest>(
        Unsupported::REASON("AVAHI support is not enabled..\n"));
#endif
}

void Configuration::writeConfigurationFile()
{
    if (!fs::exists(DNS_CONF_DIR))
        return;

    // g_mutex.lock();
    config::Parser config;
    {
        auto [setting, hn] = ddnsIface::hostConf();
        auto& hostConf = config.map["HostConf"].emplace_back();
        hostConf["Automatic"].emplace_back(setting == true ? "true" : "false");
        hostConf["Hostname"].emplace_back(hn);
    }
    {
        auto& mDNS = config.map["mDNS"].emplace_back();
        mDNS["UseMDNS"].emplace_back(ddnsIface::useMDNS() ? "true" : "false");
    }
#if 0
    {
        auto [DHCP, priority, name] = ddnsIface::domainConf();
        auto& domain = config.map["DomainConf"].emplace_back();
        domain["DomainDHCP"].emplace_back((DHCP && dnsEnabled()) == true ? "DHCP" : "Static");
        if (priority == 1) {
            domain["DomainPriority"].emplace_back("v4");
        } else if (priority == 2) {
            domain["DomainPriority"].emplace_back("v6");
        } else {
            domain["DomainPriority"].emplace_back("static");
        }

        if (name.size() != 0) {
            domain["StaticDomainName"].emplace_back((DHCP && dnsEnabled()) == true ? "" : name);
        }
        else {
            domain["StaticDomainName"].emplace_back("");
        }
    }
#endif
    {
        auto conf = interfacesConf();
        auto& ii = config.map["Interfaces"].emplace_back();
        for (auto it = conf.begin(); it != conf.end(); it++)
        {
            auto [interface, doNsupdate, tsig, method] = (*it);
            auto& ifConf = config.map[interface].emplace_back();
            auto iface = manager.get().interfaces.find(interface);
            if (iface == manager.get().interfaces.end())
            {
                lg2::info("No interface ({INTERFACE}) found\n", "INTERFACE",
                          interface);
                return;
            }
            ifConf["Do"].emplace_back(method == ddnsIface::Method::Register
                                          ? "Register"
                                          : "De-Register");
            ifConf["DoNsupdate"].emplace_back(doNsupdate == true ? "true"
                                                                 : "false");
#if TSIG_SUPPORT
            ifConf["UseTSIG"].emplace_back(tsig == true ? "true" : "false");
#else
            ifConf["UseTSIG"].emplace_back("false");
#endif                                 
            if (auto names = getDomainName(interface); (int)names.size() > 0)
            {
                for (auto& name : names)
                {
                    ifConf["DomainName"].emplace_back(name);
                }
            }

            std::vector<std::string> dnsServers = getDNSServer(interface);
            for (auto& vv : dnsServers)
            {
                ifConf["DNS"].emplace_back(vv);
            }
            for (auto& addr : iface->second->addrs)
            {
                std::string ip = stdplus::toStr(addr.first);
                bool ipv6 = ip.find(":") == std::string::npos ? false : true;
                auto index = ip.find_first_of("/");
                ip.assign(ip.begin(), ip.begin() + index);
                if (ipv6)
                {
                    in6_addr tmp = stdplus::fromStr<stdplus::In6Addr>(ip);
                    if (IN6_IS_ADDR_LINKLOCAL((in6_addr*)&tmp))
                        continue;
                }

                ifConf["IP"].emplace_back(ip);
            }

            ii["Linked"].emplace_back(interface);
        }
    }
    {
        config.map["DDNS"].emplace_back()["SendNsupdate"].emplace_back(
            ddnsIface::sendNsupdateEnabled() ? "true" : "false");
    }

    config.writeFile(DNS_CONF);
    // g_mutex.unlock();
    lg2::info("Wrote dns file: {DNS_CONF}", "DNS_CONF", DNS_CONF);
}

int16_t Configuration::updateDNSInfo(bool bakupInfo)
{
    config::Parser conf;
    std::string filePath;
    if (bakupInfo)
    {
        filePath = DNS_CONF_BAK;
    }
    else
    {
        filePath = DNS_CONF;
    }

    std::tuple<bool, std::string> tmpHost;
    std::vector<std::tuple<std::string, bool, bool, ddnsIface::Method>>
        tmpInterface;
#if 0
    std::tuple<bool, uint8_t, std::string> tmpDomain;
#endif
    bool mDNS = false;

    if (fs::exists(filePath))
    {
        if(!conf.map.getLastValueString("HostConf", "Automatic") ||
			!conf.map.getLastValueString("HostConf", "Hostname") ||
			!conf.map.getLastValueString("mDNS", "UseMDNS") ||
			!conf.map.getLastValueString("DDNS", "SendNsupdate"))
        {
            log<level::ERR>("Skipping host update due to missing values");
            return -1;
        }
        conf.setFile(filePath);
        {
            tmpHost = std::make_tuple(
                *conf.map.getLastValueString("HostConf", "Automatic") == "true"
                    ? true
                    : false,
                *conf.map.getLastValueString("HostConf", "Hostname"));
        }
#if 0
        {
            uint8_t priority = 0;
            if(!conf.map.getLastValueString("DomainConf", "DomainPriority") ||
                        !conf.map.getLastValueString("DomainConf", "DomainPriority") ||
                        !conf.map.getLastValueString("DomainConf", "DomainDHCP") ||
                        !conf.map.getLastValueString("DomainConf", "StaticDomainName"))
            {
                log<level::ERR>("Skipping host update due to missing values");
                return -1;
            }
            if ( *conf.map.getLastValueString("DomainConf", "DomainPriority") == "v4" ) {
                priority = 1;
            } else if ( *conf.map.getLastValueString("DomainConf", "DomainPriority") == "v6" ) {
                priority = 2;
            }

            tmpDomain = std::make_tuple(
                *conf.map.getLastValueString("DomainConf", "DomainDHCP") == "Static" ? 0 : 1,
                priority,
                *conf.map.getLastValueString("DomainConf", "StaticDomainName")
            );
        }
#endif
        {
            std::vector<std::string> list =
                conf.map.getValueStrings("Interfaces", "Linked");
            for (auto it = list.begin(); it != list.end(); it++)
            {
                if(!conf.map.getLastValueString(*it, "DoNsupdate") ||
                        !conf.map.getLastValueString(*it, "UseTSIG") ||
                        !conf.map.getLastValueString(*it, "Do"))
                {
                    log<level::ERR>("Skipping host update due to missing values");
                    return -1;
                }
                tmpInterface.push_back(std::make_tuple(
                    *it,
                    *conf.map.getLastValueString(*it, "DoNsupdate") == "true"
                        ? true
                        : false,
                    *conf.map.getLastValueString(*it, "UseTSIG") == "true"
                        ? true
                        : false,
                    *conf.map.getLastValueString(*it, "Do") == "Register"
                        ? ddnsIface::Method::Register
                        : ddnsIface::Method::Deregister));
            }
        }
        {
            mDNS = *conf.map.getLastValueString("mDNS", "UseMDNS") == "true"
                       ? true
                       : false;
        }
        if (bakupInfo)
        {
            preUseMDNS = mDNS;
            preHost = std::move(tmpHost);
            preIfaceConf = std::move(tmpInterface);
            preDns.clear();
            preDomain.clear();
            preIPAddr.clear();
            for (auto it = preIfaceConf.begin(); it != preIfaceConf.end(); it++)
            {
                std::string iName;
                bool doNsupdate, tsig;
                Method method;
                std::tie(iName, doNsupdate, tsig, method) = (*it);
                std::vector<std::string> list = conf.map.getValueStrings(iName,
                                                                         "DNS");
                preDns.push_back(std::make_tuple(iName, list));
                list = conf.map.getValueStrings(iName, "IP");
                preIPAddr.push_back(std::make_tuple(iName, list));
                std::vector<std::string> domainNamelist =
                    conf.map.getValueStrings(iName, "DomainName");
                preDomain.push_back(std::make_tuple(iName, domainNamelist));
            }
        }
        else
        {
            if (*conf.map.getLastValueString("DDNS", "SendNsupdate") == "true")
            {
                ddnsIface::sendNsupdateEnabled(true);
            }
            else
            {
                ddnsIface::sendNsupdateEnabled(false);
            }
            ddnsIface::hostConf(tmpHost);
#if 0
            ddnsIface::domainConf(tmpDomain);
#endif
            ddnsIface::interfacesConf(tmpInterface);
            ddnsIface::useMDNS(mDNS);
        }
    }
    return 0;
}

bool Configuration::sendNsupdateEnabled(bool value)
{
    if (value == ddnsIface::sendNsupdateEnabled())
    {
        return value;
    }

    ddnsIface::sendNsupdateEnabled(value);
    if (!value)
    {
        NsupdateEnabledChanged = true;
        toDeregister();
        NsupdateEnabledChanged = false;
    }
    writeConfigurationFile();
    return value;
}

} // namespace dns
} // namespace network
} // namespace phosphor
